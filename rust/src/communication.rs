use crate::character::CharacterTraits;
use crate::values::DragonValues;

/// Type of communication being sent
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CommunicationType {
    /// Communication expressing a value the sender cares about
    ValueAlignment,
    /// Communication type for value conflicts (detected by receiver, not generated by sender)
    /// Kept for handling edge cases in response processing
    /// Note: Never constructed by sender, but handled in receiver response processing
    #[allow(dead_code)]
    ValueConflict,
    /// Neutral or generic communication
    Neutral,
    /// Aggressive or confrontational communication
    Confrontational,
    /// Friendly or warm communication
    Friendly,
    /// Playful or fun communication
    Playful,
    /// Curious or exploratory communication
    Curious,
    /// Shy or tentative communication
    Shy,
}

/// Tone or intent of the communication
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CommunicationTone {
    Positive,
    Neutral,
    Negative,
    Warm,
    Challenging,
    Tentative,
}

/// A structured communication packet sent from one dragon to another
#[derive(Debug, Clone)]
pub struct Communication {
    /// Type of communication
    pub comm_type: CommunicationType,
    /// Tone/intent of the communication
    /// Note: Currently set but not actively used in processing - kept for future features
    #[allow(dead_code)]
    pub tone: CommunicationTone,
    /// Primary value that influenced this communication (if value-based)
    pub primary_value: Option<String>,
    /// Primary trait that influenced this communication (if trait-based)
    pub primary_trait: Option<String>,
    /// The actual message content
    pub content: String,
    /// Strength/intensity of the communication (0-100)
    pub intensity: u32,
}

impl Communication {
    pub fn new(
        comm_type: CommunicationType,
        tone: CommunicationTone,
        content: String,
        intensity: u32,
    ) -> Self {
        Communication {
            comm_type,
            tone,
            primary_value: None,
            primary_trait: None,
            content,
            intensity,
        }
    }

    pub fn with_value(mut self, value: String) -> Self {
        self.primary_value = Some(value);
        self
    }

    pub fn with_trait(mut self, trait_name: String) -> Self {
        self.primary_trait = Some(trait_name);
        self
    }
}

/// How a dragon responds to a communication
#[derive(Debug, Clone)]
pub struct CommunicationResponse {
    /// How the receiver interpreted the communication
    pub interpretation: String,
    /// The response message
    pub response_content: String,
    /// How the receiver's opinion changes based on this communication
    pub opinion_change: i32,
    /// Whether the response was positive, neutral, or negative
    pub response_tone: CommunicationTone,
}

impl CommunicationResponse {
    pub fn new(
        interpretation: String,
        response_content: String,
        opinion_change: i32,
        response_tone: CommunicationTone,
    ) -> Self {
        CommunicationResponse {
            interpretation,
            response_content,
            opinion_change,
            response_tone,
        }
    }
}

/// Generate a communication based on a dragon's values and traits
/// The communication is generated purely from the sender's perspective,
/// without knowledge of the receiver's internal values or traits.
/// The sender's opinion of the receiver can influence the communication.
pub fn generate_communication(
    sender_values: &DragonValues,
    sender_traits: &CharacterTraits,
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    // Determine sender's primary values
    let top_sender_values = get_top_values(sender_values, 3);
    
    // Check if sender has high values that they want to express
    // This is based purely on the sender's values, not comparing to receiver
    for (value_name, sender_val) in &top_sender_values {
        if *sender_val > 70 {
            // Sender wants to express this value - create value-based communication
            // The tone/intensity may be influenced by existing opinion
            return create_value_expressing_communication(
                value_name,
                sender_name,
                receiver_name,
                sender_element,
                receiver_element,
                existing_opinion,
            );
        }
    }

    // Trait-based communications (based purely on sender's traits)
    if sender_traits.friendliness > 70 && sender_traits.playfulness > 60 {
        return create_playful_communication(
            sender_name,
            receiver_name,
            sender_element,
            receiver_element,
            existing_opinion,
        );
    }
    
    if sender_traits.friendliness > 70 {
        return create_friendly_communication(
            sender_name,
            receiver_name,
            sender_element,
            receiver_element,
            existing_opinion,
        );
    }
    
    if sender_traits.curiosity > 70 {
        return create_curious_communication(
            sender_name,
            receiver_name,
            sender_element,
            receiver_element,
            existing_opinion,
        );
    }
    
    if sender_traits.sociability < 30 {
        return create_shy_communication(
            sender_name,
            receiver_name,
            sender_element,
            receiver_element,
            existing_opinion,
        );
    }
    
    if sender_traits.aggression > 70 {
        return create_confrontational_communication(
            sender_name,
            receiver_name,
            sender_element,
            receiver_element,
            existing_opinion,
        );
    }

    // Default neutral communication
    create_neutral_communication(sender_name, receiver_name, sender_element, receiver_element, existing_opinion)
}

/// Create a communication expressing the sender's value
/// The sender expresses what they care about, without knowing if the receiver shares it
fn create_value_expressing_communication(
    value_name: &str,
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    // Intensity may be influenced by existing opinion (more intense if positive opinion)
    let base_intensity = match value_name {
        "honor" => 85,
        "wisdom" => 80,
        "community" | "protection" => 75,
        "harmony" => 70,
        _ => 70,
    };
    let intensity = if existing_opinion > 20 {
        (base_intensity as f32 * 1.1) as u32
    } else if existing_opinion < -20 {
        (base_intensity as f32 * 0.9) as u32
    } else {
        base_intensity
    }.min(100);

    let tone = if existing_opinion > 20 {
        CommunicationTone::Warm
    } else if existing_opinion < -20 {
        CommunicationTone::Neutral
    } else {
        CommunicationTone::Positive
    };

    let content = match value_name {
        "honor" => format!("{} ({}) makes a solemn promise to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        "community" => format!("{} ({}) proposes working together with {} ({}) for the clan's benefit", sender_name, sender_element, receiver_name, receiver_element),
        "harmony" => format!("{} ({}) seeks peaceful resolution with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        "wisdom" => format!("{} ({}) engages {} ({}) in deep philosophical discussion", sender_name, sender_element, receiver_name, receiver_element),
        "protection" => format!("{} ({}) offers protection and support to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        "freedom" => format!("{} ({}) emphasizes the importance of individual freedom to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        "tradition" => format!("{} ({}) speaks to {} ({}) about the value of tradition", sender_name, sender_element, receiver_name, receiver_element),
        "growth" => format!("{} ({}) discusses the importance of progress and growth with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        "achievement" => format!("{} ({}) talks to {} ({}) about striving for excellence", sender_name, sender_element, receiver_name, receiver_element),
        "power" => format!("{} ({}) discusses the pursuit of influence and power with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        _ => format!("{} ({}) expresses their values to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    };

    Communication::new(CommunicationType::ValueAlignment, tone, content, intensity)
        .with_value(value_name.to_string())
}

// Removed create_value_conflict_communication - conflicts are now determined
// by the receiver's response, not by comparing values during generation

fn create_playful_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let intensity = if existing_opinion > 20 { 75 } else { 70 };
    let messages = vec![
        format!("{} ({}) invites {} ({}) to play an energetic game", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) suggests a fun activity to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) playfully challenges {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    ];
    let content = messages[rng.gen_range(0..messages.len())].clone();
    Communication::new(CommunicationType::Playful, CommunicationTone::Positive, content, intensity)
        .with_trait("playfulness".to_string())
}

fn create_friendly_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let intensity = if existing_opinion > 20 { 70 } else { 65 };
    let messages = vec![
        format!("{} ({}) greets {} ({}) warmly", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) shares a friendly conversation with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) offers help to {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    ];
    let content = messages[rng.gen_range(0..messages.len())].clone();
    Communication::new(CommunicationType::Friendly, CommunicationTone::Warm, content, intensity)
        .with_trait("friendliness".to_string())
}

fn create_curious_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let intensity = if existing_opinion > 20 { 65 } else { 60 };
    let messages = vec![
        format!("{} ({}) asks {} ({}) about something interesting", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) suggests exploring something together with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) shares curiosity with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    ];
    let content = messages[rng.gen_range(0..messages.len())].clone();
    Communication::new(CommunicationType::Curious, CommunicationTone::Positive, content, intensity)
        .with_trait("curiosity".to_string())
}

fn create_shy_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let intensity = if existing_opinion > 20 { 45 } else { 40 };
    let messages = vec![
        format!("{} ({}) tentatively approaches {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) quietly greets {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    ];
    let content = messages[rng.gen_range(0..messages.len())].clone();
    Communication::new(CommunicationType::Shy, CommunicationTone::Tentative, content, intensity)
        .with_trait("sociability".to_string())
}

fn create_confrontational_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    let content = if existing_opinion < -20 {
        format!("{} ({}) confronts {} ({}) - they don't get along", sender_name, sender_element, receiver_name, receiver_element)
    } else {
        format!("{} ({}) challenges {} ({})", sender_name, sender_element, receiver_name, receiver_element)
    };
    Communication::new(CommunicationType::Confrontational, CommunicationTone::Challenging, content, 75)
        .with_trait("aggression".to_string())
}

fn create_neutral_communication(
    sender_name: &str,
    receiver_name: &str,
    sender_element: &str,
    receiver_element: &str,
    existing_opinion: i32,
) -> Communication {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let intensity = if existing_opinion > 20 { 55 } else if existing_opinion < -20 { 45 } else { 50 };
    let messages = vec![
        format!("{} ({}) exchanges a brief nod with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) acknowledges {} ({})", sender_name, sender_element, receiver_name, receiver_element),
        format!("{} ({}) has a polite conversation with {} ({})", sender_name, sender_element, receiver_name, receiver_element),
    ];
    let content = messages[rng.gen_range(0..messages.len())].clone();
    Communication::new(CommunicationType::Neutral, CommunicationTone::Neutral, content, intensity)
}

/// Process a communication and generate a response
pub fn process_communication(
    communication: &Communication,
    receiver_values: &DragonValues,
    receiver_traits: &CharacterTraits,
    receiver_name: &str,
    sender_name: &str,
    existing_opinion: i32,
) -> CommunicationResponse {
    // How the receiver interprets the communication based on their values and traits
    let interpretation = interpret_communication(communication, receiver_values, receiver_traits, receiver_name, existing_opinion);
    
    // Generate response based on interpretation
    let (response_content, opinion_change, response_tone) = generate_response(
        communication,
        &interpretation,
        receiver_values,
        receiver_traits,
        receiver_name,
        sender_name,
        existing_opinion,
    );

    CommunicationResponse::new(interpretation, response_content, opinion_change, response_tone)
}

fn interpret_communication(
    communication: &Communication,
    receiver_values: &DragonValues,
    receiver_traits: &CharacterTraits,
    receiver_name: &str,
    _existing_opinion: i32,
) -> String {
    match communication.comm_type {
        CommunicationType::ValueAlignment => {
            if let Some(ref value_name) = communication.primary_value {
                let receiver_val = get_value(receiver_values, value_name);
                if receiver_val > 70 {
                    format!("{} resonates with the shared value of {}", receiver_name, value_name)
                } else if receiver_val < 30 {
                    format!("{} doesn't share the same priority for {}", receiver_name, value_name)
                } else {
                    format!("{} acknowledges the value of {}", receiver_name, value_name)
                }
            } else {
                format!("{} receives the communication positively", receiver_name)
            }
        }
        CommunicationType::ValueConflict => {
            format!("{} perceives a conflict in values", receiver_name)
        }
        CommunicationType::Playful => {
            if receiver_traits.playfulness > 60 {
                format!("{} is excited by the playful invitation", receiver_name)
            } else if receiver_traits.playfulness < 30 {
                format!("{} finds the playfulness a bit much", receiver_name)
            } else {
                format!("{} accepts the playful gesture", receiver_name)
            }
        }
        CommunicationType::Friendly => {
            if receiver_traits.friendliness > 60 {
                format!("{} appreciates the friendly gesture", receiver_name)
            } else {
                format!("{} responds politely", receiver_name)
            }
        }
        CommunicationType::Curious => {
            if receiver_traits.curiosity > 60 {
                format!("{} shares the curiosity", receiver_name)
            } else {
                format!("{} acknowledges the inquiry", receiver_name)
            }
        }
        CommunicationType::Shy => {
            if receiver_traits.sociability < 30 {
                format!("{} appreciates the gentle approach", receiver_name)
            } else {
                format!("{} responds warmly", receiver_name)
            }
        }
        CommunicationType::Confrontational => {
            if receiver_traits.aggression > 70 {
                format!("{} rises to the challenge", receiver_name)
            } else if receiver_traits.aggression < 30 {
                format!("{} is unsettled by the confrontation", receiver_name)
            } else {
                format!("{} responds defensively", receiver_name)
            }
        }
        CommunicationType::Neutral => {
            format!("{} receives the communication neutrally", receiver_name)
        }
    }
}

fn generate_response(
    communication: &Communication,
    _interpretation: &str,
    receiver_values: &DragonValues,
    receiver_traits: &CharacterTraits,
    receiver_name: &str,
    sender_name: &str,
    existing_opinion: i32,
) -> (String, i32, CommunicationTone) {
    match communication.comm_type {
        CommunicationType::ValueAlignment => {
            if let Some(ref value_name) = communication.primary_value {
                let receiver_val = get_value(receiver_values, value_name);
                
                // Check if the sender's expressed value conflicts with receiver's high values
                let conflicts = check_value_conflicts(value_name, receiver_values);
                if conflicts {
                    (format!("{} disagrees with {}'s perspective on {}", receiver_name, sender_name, value_name), -5, CommunicationTone::Negative)
                } else if receiver_val > 70 {
                    // Shared high value - positive response
                    (format!("{} enthusiastically agrees with {} about {}", receiver_name, sender_name, value_name), 10 + (communication.intensity as i32 / 10), CommunicationTone::Positive)
                } else if receiver_val < 30 {
                    // Receiver doesn't prioritize this value
                    (format!("{} politely acknowledges but doesn't share the same priority for {}", receiver_name, value_name), -3, CommunicationTone::Neutral)
                } else {
                    // Moderate value alignment
                    (format!("{} appreciates {}'s perspective on {}", receiver_name, sender_name, value_name), 5, CommunicationTone::Positive)
                }
            } else {
                (format!("{} responds positively", receiver_name), 5, CommunicationTone::Positive)
            }
        }
        CommunicationType::ValueConflict => {
            (format!("{} disagrees with the conflicting perspective", receiver_name), -5, CommunicationTone::Negative)
        }
        CommunicationType::Playful => {
            if receiver_traits.playfulness > 60 {
                (format!("{} joins in the fun enthusiastically", receiver_name), 12, CommunicationTone::Positive)
            } else if receiver_traits.playfulness < 30 {
                (format!("{} participates but isn't as enthusiastic", receiver_name), -2, CommunicationTone::Neutral)
            } else {
                (format!("{} enjoys the playful interaction", receiver_name), 8, CommunicationTone::Positive)
            }
        }
        CommunicationType::Friendly => {
            if receiver_traits.friendliness > 60 {
                (format!("{} responds warmly and reciprocates the friendliness", receiver_name), 8, CommunicationTone::Warm)
            } else {
                (format!("{} responds politely", receiver_name), 4, CommunicationTone::Neutral)
            }
        }
        CommunicationType::Curious => {
            if receiver_traits.curiosity > 60 {
                (format!("{} shares the curiosity and engages deeply", receiver_name), 10, CommunicationTone::Positive)
            } else {
                (format!("{} responds to the inquiry", receiver_name), 5, CommunicationTone::Neutral)
            }
        }
        CommunicationType::Shy => {
            if receiver_traits.sociability < 30 {
                (format!("{} appreciates the gentle approach and opens up", receiver_name), 6, CommunicationTone::Positive)
            } else {
                (format!("{} responds warmly to the tentative approach", receiver_name), 3, CommunicationTone::Neutral)
            }
        }
        CommunicationType::Confrontational => {
            if receiver_traits.aggression > 70 {
                (format!("{} rises to the challenge and confronts back", receiver_name), if existing_opinion < 0 { -20 } else { -10 }, CommunicationTone::Challenging)
            } else if receiver_traits.aggression < 30 {
                (format!("{} is hurt by the confrontation and withdraws", receiver_name), -15, CommunicationTone::Negative)
            } else {
                (format!("{} responds defensively", receiver_name), -8, CommunicationTone::Negative)
            }
        }
        CommunicationType::Neutral => {
            (format!("{} responds neutrally", receiver_name), 2, CommunicationTone::Neutral)
        }
    }
}

// Helper functions
fn get_top_values(values: &DragonValues, count: usize) -> Vec<(String, u32)> {
    let mut value_entries = vec![
        ("honor".to_string(), values.honor),
        ("freedom".to_string(), values.freedom),
        ("tradition".to_string(), values.tradition),
        ("growth".to_string(), values.growth),
        ("community".to_string(), values.community),
        ("achievement".to_string(), values.achievement),
        ("harmony".to_string(), values.harmony),
        ("power".to_string(), values.power),
        ("wisdom".to_string(), values.wisdom),
        ("protection".to_string(), values.protection),
    ];
    value_entries.sort_by(|a, b| b.1.cmp(&a.1));
    value_entries.into_iter().take(count).collect()
}

fn get_value(values: &DragonValues, name: &str) -> u32 {
    match name {
        "honor" => values.honor,
        "freedom" => values.freedom,
        "tradition" => values.tradition,
        "growth" => values.growth,
        "community" => values.community,
        "achievement" => values.achievement,
        "harmony" => values.harmony,
        "power" => values.power,
        "wisdom" => values.wisdom,
        "protection" => values.protection,
        _ => 0,
    }
}

/// Check if a sender's expressed value conflicts with the receiver's high values
fn check_value_conflicts(sender_value: &str, receiver_values: &DragonValues) -> bool {
    // Define conflicting value pairs
    let conflict_pairs = vec![
        ("freedom", "community"),
        ("community", "freedom"),
        ("tradition", "growth"),
        ("growth", "tradition"),
        ("power", "harmony"),
        ("harmony", "power"),
    ];
    
    for (val1, val2) in conflict_pairs {
        if sender_value == val1 {
            let receiver_val2 = get_value(receiver_values, val2);
            if receiver_val2 > 70 {
                return true;
            }
        }
    }
    
    false
}

